<!doctype html>
<html>
<head>

	<meta charset="utf-8">
	<title>cart</title>
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

	<link rel="stylesheet" type="text/css" href="../../css/flexus-material.css">
	<!--
	<link rel="stylesheet" type="text/css" href="../../util/phone-only-demo.css">
	-->
	<link rel="stylesheet" type="text/css" href="./cart.css">

</head>
<body theme="white" primary="purple">

	<flexus-view id="cart">
		<flexus-toolbar tinted elevation="0">
			<button icon="menu"></button>
			<div flex>Cart</div>
			<button icon="search"></button>
			<button icon="more"></button>
		</flexus-toolbar>
		<main>

			<div v-on:click="openDetail($event, product.id)"
			fx-item seamed="between"
			transition-origin :name="`product-${product.id}`"
			v-for="product in products">
				<img square avatar :src="product.image">
				<div vertical layout flex>
					<div>${product.name}</div>
					<div body2 muted>${product.status}</div>
				</div>
				<span>$${product.price.toFixed(2)}</span>
			</div>

			<div fx-item>
				<span flex muted>TOTAL</span>
				<span h5>$41.24</span>
			</div>

			<p layout body2>
				<span flex>Subtotal</span>
				<span muted>$36.00</span>
			</p>
			<p layout body2>
				<span flex>Shipping</span>
				<span muted>$2.00</span>
			</p>
			<p layout body2>
				<span flex>Tax</span>
				<span muted>$3.24</span>
			</p>

		</main>

		<button flat fullwidth bottom>checkout</button>

	</flexus-view>


	<flexus-view id="detail" :name="`product-${product.id}`">

		<flexus-toolbar seamed>
			<button icon="x" v-on:click="goBack"></button>
			<div flex>Product details</div>
			<button icon="search"></button>
			<button icon="more"></button>
		</flexus-toolbar>

		<main vertical layout>
			<div fullbleed ratio="4:3">
				<img fit :src="product.image">
			</div>
			<div layout top>
				<div vertical layout flex>
					<span h5>${product.name}</span>
					<span body2 muted>${product.status}</span>
				</div>
				<span h5 muted>$${product.price.toFixed(2)}</span>
			</div>
			<p body2>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus fringilla tempus massa, et mollis nisl laoreet et. Aliquam feugiat odio at luctus ultrices.</p>
			<p body2></p>Integer elementum imperdiet risus. Mauris hendrerit massa vel nulla tempus, non semper felis semper. Nulla gravida dignissim lorem, eu volutpat nibh ornare at. Integer hendrerit dapibus tempor. Aenean at hendrerit risus. Integer vehicula porttitor nibh.</p>
			<button seamed fullwidth bottom v-on:click="remove">remove from cart</button>
		</main>

	</flexus-view>



	<script src="../util/vue.js"></script>

	<script type="module">
		// WORK IN PROGRESS CODE !!!
		import {ViewTransition} from '../../src/js/animations/ViewTransition.js'
		import {setTransitionClass} from './cart-vue-app.js'

		function mapRange(num, inMin, inMax, outMin, outMax) {
			return (num - inMin) * (outMax - outMin) / (inMax - inMin) + outMin
		}



		// TODO: simplify the class
		class TransitionOverlap extends ViewTransition {

			setup() {
				super.setup()
				console.log('TransitionOverlap SETUP')
				console.log('this.originBbox', this.originBbox)
				this.duration = 2000

				console.log('this.origin', this.origin)

				this.origin.style.willChange = 'transform, opacity'
				this.calculateOrigin()

				this.createBackdrop()
				this.createSheet()

				this.aboveMain = this.baseView.querySelector(':scope > flexus-toolbar')
							|| this.baseView.querySelector(':scope > flexus-tabs')

				// MD spec wants to delay the animation until edges of toolbar and animated element are touching
				// to make it look like the animated element pushes toolbar away.
				// This is an ugly calculation that somewhat does the job (I'm not a mathematician. send halp pls).
				// NOTE: It'd be nice to use the actual bezier curve used to animate the element.
				if (this.aboveMain/* && isElevated(this.aboveMain)*/) {
					let top = this.originBbox.top - this.baseViewBbox.top
					// Distance between bottom edge of toolbar and origin's top edge.
					let distFromToolbar = top - this.aboveMain.offsetHeight
					let radians = mapRange(distFromToolbar * 2, 0, this.newViewBbox.height, 0, Math.PI / 2)
					let delay = 0.1 + (Math.sin(radians) * 0.45)
					this.schedule(this.aboveMain, {
						transform: [
							'translate3d(0, 0%, 0)',
							'translate3d(0, -100%, 0)',
						],
					}, delay, 1)
				}

				if (this.allowScalingOrigin) {
					var originTransformKeyframes = {
						transformOrigin: ['left top', 'left top'],
						transform: [
							`translateX(0) translateY(0) scale(1)`,
							`translateX(${this.newViewBbox.left - this.originBbox.left}px) translateY(${this.newViewBbox.top - this.originBbox.top}px) scale(${scale})`
						],
						boxShadow: ['none', 'none']
					}
				} else {
					var originTransformKeyframes = {
						transform: [
							`translateX(0) translateY(0)`,
							`translateX(${this.newViewBbox.left - this.originBbox.left}px) translateY(${this.newViewBbox.top - this.originBbox.top}px)`
						],
						boxShadow: ['none', 'none']
					}
				}

				if (this.allowOriginEdges && this.originSideX === 'right') {
					var newViewMoveKeyframes = {
						transform: [
							`translateX(${this.originBbox.right - this.newViewBbox.right}px) translateY(${this.originBbox.top - this.newViewBbox.top}px)`,
							`translateX(0) translateY(0)`
						],
						clipPath: [
							`polygon(calc(100% - ${this.originBbox.width}px) 0, 100% 0, 100% ${this.originBbox.height}px, calc(100% - ${this.originBbox.width}px) ${this.originBbox.height}px)`,
							`polygon(0 0, 100% 0, 100% 100%, 0% 100%)`,
						],
					}
				} else {
					var newViewMoveKeyframes = {
						transform: [
							`translateX(${this.originBbox.left - this.newViewBbox.left}px) translateY(${this.originBbox.top - this.newViewBbox.top}px)`,
							`translateX(0) translateY(0)`
						],
						clipPath: [
							`polygon(0 0, ${this.originBbox.width}px 0, ${this.originBbox.width}px ${this.originBbox.height}px, 0% ${this.originBbox.height}px)`,
							`polygon(0 0, 100% 0, 100% 100%, 0% 100%)`,
						],
					}
				}

				this.fade(this.backdrop, 0, 0.3, 0, 0.4)
				this.elevate(this.sheet, this.originComputed.boxShadow, 8, 0, 0.2)

				this.scheduleSheetResize(0.1, 1)
				this.schedule(this.origin,  originTransformKeyframes, 0.1, 1)
				this.schedule(this.newView, newViewMoveKeyframes,     0.1, 1)

				this.fadeOut(this.origin, 0, 0.5)
				this.fadeIn(this.newView, 0.3, 1)

			}

			async in() {
				try {
					await super.in()
				} catch(err) {
					throw err
				} finally {
					this.backdrop.remove()
					this.sheet.remove()
				}
			}

			async out() {
				try {
					await super.out()
				} catch(err) {
					throw err
				} finally {
					this.backdrop.remove()
					this.sheet.remove()
				}
			}

		}

		setTransitionClass(TransitionOverlap)


		function isElevated(node, computed) {
			var attr = Number(node.getAttribute('elevation'))
			if (!Number.isNaN(attr)) return attr > 0
			if (!computed) computed = window.getComputedStyle(node)
			if (computed.boxShadow === 'none') return false
			return computed.boxShadow
				// split string by commas that are outside of parenthesis (rgba colors)
				.split(/\,\s?(?![^\(]*\))/)
				.some(shadow => {
					// Split by all spaces that are outside of parenthesis.
					var parts = shadow.split(/\s(?![^\(]*\))/)
					var color = parts.find(isColor)
					var sizes = parts.filter(part => !isColor(part))
					var size = sizes.map(str => str.replace(/\D/g, '')).map(Number).reduce((a,b) => a + b)
					return size > 0 && !isTransparent(color)
				})
		}

		function isColor(string) {
			return string.includes('#')
				|| string.includes('rgb')
				|| string.includes('hsl')
		}

		function isTransparent(string) {
			if (string.includes('a(')) {
				var alpha = string.slice(5, -1).split(',').map(Number).pop()
				return alpha === 0
			} else {
				return string.startsWith('#')
					&& string.length === 5 && string[4] === '0'
					&& string.length === 9 && string.slice(-2) === '00'
			}
		}

	</script>

</body>
</html>
