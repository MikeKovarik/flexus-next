<!doctype html>
<html>
<head>

	<meta charset="utf-8">
	<title>cart</title>
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

	<link rel="stylesheet" type="text/css" href="../../css/flexus-material.css">
	<!--
	<link rel="stylesheet" type="text/css" href="../../util/phone-only-demo.css">
	-->
	<link rel="stylesheet" type="text/css" href="./cart.css">

	<style>
		[card]:nth-of-type(1) {
			/*
			TOP LEFT IS THE DEFAULT
			transform-origin: top left;
			*/
		}
		[card]:nth-of-type(2) {
			transform-origin: top right;
		}
		[card]:nth-of-type(3) {
			transform-origin: bottom left;
		}
		[card]:nth-of-type(4) {
			transform-origin: bottom right;
		}
		[card] > img {
			max-height: 140px;
		}
	</style>

</head>
<body primary="purple">

	<flexus-view id="cart" theme="light">
		<flexus-toolbar tinted elevation="0">
			<button icon="menu"></button>
			<div flex>Cart</div>
			<button icon="search"></button>
			<button icon="more"></button>
		</flexus-toolbar>
		<main>

			<div grid spaced="1" columns="2">
				<div card nopadding vertical layout
				v-on:click="openDetail($event, product.id)"
				transition-origin :name="`product-${product.id}`"
				v-for="product in products">
					<img :src="product.image" flex cover>
					<div padded horizontal layout>
						<div vertical layout flex>
							<div>${product.name}</div>
							<div body2 muted>${product.status}</div>
						</div>
						<span>$${product.price.toFixed(2)}</span>
					</div>
				</div>
			</div>

			<div fx-item>
				<span flex muted>TOTAL</span>
				<span h5>$41.24</span>
			</div>

			<p layout body2>
				<span flex>Subtotal</span>
				<span muted>$36.00</span>
			</p>
			<p layout body2>
				<span flex>Shipping</span>
				<span muted>$2.00</span>
			</p>
			<p layout body2>
				<span flex>Tax</span>
				<span muted>$3.24</span>
			</p>

		</main>

		<flexus-tabs elevation="8">
			<button vertical icon="map" transparent>some</button>
			<button vertical icon="edit" transparent>bottom</button>
			<button vertical icon="save" transparent>tabs</button>
		</flexus-tabs>
		<!--
		<button flat fullwidth bottom>checkout</button>
		-->
	</flexus-view>


	<flexus-view id="detail" :name="`product-${product.id}`" theme="white">

		<flexus-toolbar seamed>
			<button icon="x" v-on:click="goBack"></button>
			<div flex>Product details</div>
			<button icon="search"></button>
			<button icon="more"></button>
		</flexus-toolbar>

		<main vertical layout>
			<div fullbleed ratio="4:3">
				<img fit :src="product.image">
			</div>
			<div layout top>
				<div vertical layout flex>
					<span h5>${product.name}</span>
					<span body2 muted>${product.status}</span>
				</div>
				<span h5 muted>$${product.price.toFixed(2)}</span>
			</div>
			<p body2>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus fringilla tempus massa, et mollis nisl laoreet et. Aliquam feugiat odio at luctus ultrices.</p>
			<p body2>Integer elementum imperdiet risus. Mauris hendrerit massa vel nulla tempus, non semper felis semper. Nulla gravida dignissim lorem, eu volutpat nibh ornare at. Integer hendrerit dapibus tempor. Aenean at hendrerit risus. Integer vehicula porttitor nibh.</p>
			<button seamed fullwidth bottom v-on:click="remove">remove from cart</button>
		</main>

	</flexus-view>



	<script src="../util/vue.js"></script>

	<script type="module">
		// WORK IN PROGRESS CODE !!!
		import {ViewTransition} from '../../src/js/animations/ViewTransition.js'
		import {setTransitionClass} from './cart-vue-app.js'


		// TODO: simplify the class
		class TransitionOverlap extends ViewTransition {

			//duration = 700
			//duration = 10000
			duration = 1000

			setup() {
				super.setup()

				// it's important that these nodes are located before any other are created.
				this.findSurroundingNodes()

				this.origin.style.willChange = 'transform, opacity'
				this.calculateOrigin()

				this.createBackdrop()
				this.createSheet()

				this.pushAwayElementsAbove()
				this.pushAwayElementsBelow()

				this.parseTransformOrigin(this.originComputed)
				this.allowOriginEdges = true
				let {transformOrigin, width, height} = this.originComputed
				let [originX, originY] = transformOrigin.split(' ').map(parseFloat)

				//originX = 0
				//originY = 0

				let ratioX = originX / this.originBbox.width
				let ratioXneg = 1 - ratioX
				let ratioY = originY / this.originBbox.height
				let ratioYneg = 1 - ratioY


				if (this.allowScalingOrigin) {
					let scale = 2 // todo
					var originTransformKeyframes = {
						transformOrigin: ['left top', 'left top'],
						transform: [
							`translateX(0) translateY(0) scale(1)`,
							`translateX(${this.newViewBbox.left - this.originBbox.left}px) translateY(${this.newViewBbox.top - this.originBbox.top}px) scale(${scale})`
						],
						boxShadow: ['none', 'none']
					}
				} else {
					if (this.allowOriginEdges) {
						let translate = calcTranslate(this.newViewBbox, this.originBbox, ratioX, ratioY)
						var originTransformKeyframes = {
							transform: [
								`translate(0, 0)`,
								`translate(${translate.x}px, ${translate.y}px)`
							],
							boxShadow: ['none', 'none']
						}
					}
				}

				if (this.allowOriginEdges) {
					let translate = calcTranslate(this.originBbox, this.newViewBbox, ratioX, ratioY)
					let transform = [
						`translate(${translate.x}px, ${translate.y}px)`,
						`translate(0, 0)`
					]

					const createClip = desc => `polygon(
						${desc.left} ${desc.top},
						${desc.right} ${desc.top},
						${desc.right} ${desc.bottom},
						${desc.left} ${desc.bottom}
					)`

					let left   = `calc(${100 * ratioX}% - ${this.originBbox.width * ratioX}px)`
					let right  = `calc(${100 * ratioX}% - ${this.originBbox.width * (ratioX - 1)}px)`
					let top    = `calc(${100 * ratioY}% - ${this.originBbox.height * ratioY}px)`
					let bottom = `calc(${100 * ratioY}% - ${this.originBbox.height * (ratioY - 1)}px)`

					let clipPath = [
						createClip({top, right, bottom, left}),
						`polygon(0 0, 100% 0, 100% 100%, 0% 100%)`,
					]

					var newViewMoveKeyframes = {transform, clipPath}
				}

				this.fade(this.backdrop, 0, 0.3, 0, 0.4)
				this.elevate(this.sheet, this.originComputed.boxShadow, 8, 0, 0.2)

				this.scheduleSheetResize(0.1, 1)
				if (originTransformKeyframes) this.schedule(this.origin,  originTransformKeyframes, 0.1, 1)
				if (newViewMoveKeyframes)     this.schedule(this.newView, newViewMoveKeyframes,     0.1, 1)

				this.fadeOut(this.origin, 0, 0.5)
				this.fadeIn(this.newView, 0.3, 0.7)

				this.baseMain.style.zIndex = 'unset'
			}

			async in() {
				try {
					await super.in()
				} catch(err) {
					throw err
				} finally {
					if (this.backdrop) this.backdrop.remove()
					if (this.sheet)    this.sheet.remove()
				}
			}

			async out() {
				try {
					await super.out()
				} catch(err) {
					throw err
				} finally {
					if (this.backdrop) this.backdrop.remove()
					if (this.sheet)    this.sheet.remove()
				}
			}

		}

		setTransitionClass(TransitionOverlap)


		function isElevated(node, computed) {
			var attr = Number(node.getAttribute('elevation'))
			if (!Number.isNaN(attr)) return attr > 0
			if (!computed) computed = window.getComputedStyle(node)
			if (computed.boxShadow === 'none') return false
			return computed.boxShadow
				// split string by commas that are outside of parenthesis (rgba colors)
				.split(/\,\s?(?![^\(]*\))/)
				.some(shadow => {
					// Split by all spaces that are outside of parenthesis.
					var parts = shadow.split(/\s(?![^\(]*\))/)
					var color = parts.find(isColor)
					var sizes = parts.filter(part => !isColor(part))
					var size = sizes.map(str => str.replace(/\D/g, '')).map(Number).reduce((a,b) => a + b)
					return size > 0 && !isTransparent(color)
				})
		}

		function isColor(string) {
			return string.includes('#')
				|| string.includes('rgb')
				|| string.includes('hsl')
		}

		function isTransparent(string) {
			if (string.includes('a(')) {
				var alpha = string.slice(5, -1).split(',').map(Number).pop()
				return alpha === 0
			} else {
				return string.startsWith('#')
					&& string.length === 5 && string[4] === '0'
					&& string.length === 9 && string.slice(-2) === '00'
			}
		}

		function diffBboxes(bboxA, bboxB) {
			return {
			}
		}

		function calcTranslate(bboxA, bboxB, ratioX, ratioY) {
			let ratioXneg = 1 - ratioX
			let ratioYneg = 1 - ratioY
			let left   = bboxA.left   - bboxB.left
			let right  = bboxA.right  - bboxB.right
			let top    = bboxA.top    - bboxB.top
			let bottom = bboxA.bottom - bboxB.bottom
			return {
				x: (left * ratioXneg) + (right  * ratioX),
				y: (top  * ratioYneg) + (bottom * ratioY),
			}
		}

	</script>

</body>
</html>
